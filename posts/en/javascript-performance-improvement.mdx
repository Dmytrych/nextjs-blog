---
title: "5 Habits Which Will Improve Your React Application Performance"
description: Five simple habits which will passively enhance the performance of your Javascript/React application.
date: '2023-06-03'
---

### 1 - Avoid Using UseEffect for Non-fetch Calculations

Consider following code:
```JavaScript
const Capitalize = ({text}) => {
  const [capitalizedText, setCapitalizedText] = useState("");

  useEffect(() => {
    setCapitalizedText(text.toUpperCase());
  }, [text]);

  return (
    <p>{capitalizedText}</p>
  );
};
```

This component contains useEffect, which will fire at the first render. It will instantly modify the state, so the component will re-render. But did we even need to display the page before this re-render?

Much simpler way of doing this will be - to use the following:
```JavaScript
const Capitalize = ({text}) => {
  return (
    <p>{text.toUpperCase()}</p>
  );
};
```

However, this is still not perfect. The `text.toUpperCase()` will be calculated each time the component is rendered.
At this point we are coming tho the next useful tip - memoization.

### 2 - Use Memoization for Expensive Function Calls

If you are writing any computation-intense function - always consider a possibility of caching its results. Use libraries like [memoize-one](https://www.npmjs.com/package/memoize-one) or useMemo, to avoid unnecessary computations and improve performance.

The above code can be re-written following way, to cache the result of `text.toUpperCase()`:

```JavaScript
const Capitalize = ({text}) => {
  const capitalizedText = useMemo(() => text.toUpperCase(), [name]);
  return (
    <p>{capitalizedText}</p>
  );
};
```

### 3 - Avoid Unnecessary Loops

This is a kind of universal tip for any programming language. If you are working with arrays, especially the huge ones - try to minimize the amount of iterations you perform on this array.

Consider the following function, which gets all users with name "John" and their count:
```JavaScript
function GetNamesAndSurnames(usersArray) {
  return {
    johns: usersArray.filter((user) => user.name === "John"), // 'filter' iterates through all the users for the first time
    johnsCount: usersArray.filter((user) => user.name === "John").length  // 'filter' runs for the second time
  }
}
```

This exaple is quite simple, and will not give a noticeable performance effect, however, this code may slow down the application if there is a lot of data, or if such code is used in multiple places.

The correct way of fixing this issue - is writing the result of the computation into the variable, so its result may be reused:
```JavaScript
function GetNamesAndSurnames(usersArray) {
  const johns = usersArray.filter((user) => user.name === "John"); // 'filter' runs only once
  return {
    johns,
    johnsCount: johns.length
  }
}
```

### 3 - Avoid Unnecessary Loops